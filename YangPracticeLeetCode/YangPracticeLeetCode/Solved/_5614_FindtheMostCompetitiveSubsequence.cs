using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace YangPracticeLeetCode.Solved
{
	class _5614_FindtheMostCompetitiveSubsequence
	{




		
		public static void Test()
		{
			Solution s = new Solution();

			//Console.WriteLine(s.NumPoints());

			//s.MostCompetitive(new int[] { 2, 10, 3, 5, 9, 4, 2, 0, 6, 7, 8, 0, 6, 5, 8, 1, 6, 1, 5, 5, 2, 10, 9, 5, 7, 7, 3, 2, 1, 4, 0, 7, 0, 3, 10, 10, 5, 10, 4, 7, 0, 2, 10, 9, 0, 2, 6, 10, 6, 9, 2, 1, 9, 8, 7, 2, 0, 7, 3, 6, 2, 1, 8, 0, 0, 0, 10, 4, 3, 5, 0, 8, 1, 8, 5, 1, 6, 0, 4, 4, 10, 2, 0, 5, 1, 1, 3, 3, 5, 2, 6, 5, 6, 0, 3, 8, 0, 1, 7, 0, 0, 9, 6, 10, 5, 9, 8, 9, 8, 7, 8, 10, 6, 3, 8, 0, 5, 7, 4, 3, 5, 7, 7, 0, 3, 10, 1, 3, 10, 2, 10, 3, 2, 6, 3, 10, 8, 10, 6, 0, 7, 6, 2, 10, 4, 0, 7, 4, 8, 8, 1, 7, 1, 4, 9, 7, 7, 8, 9, 8, 7, 2, 4, 9, 8, 8, 0, 8, 2, 10, 7, 3, 10, 8, 5, 1, 1, 3, 0, 5, 1, 7, 1, 7, 9, 2, 6, 9, 6, 10, 6, 1, 7, 8, 3, 6, 9, 3, 5, 9, 0, 9, 3, 5, 8, 4, 6, 8, 10, 8, 0, 9, 3, 7, 10, 4, 4, 2, 3, 7, 2, 10, 3, 5, 4, 9, 9, 2, 1, 2, 10, 4, 4, 4, 3, 5, 9, 7, 2, 0, 3, 6, 6, 7, 3, 9, 4, 6, 9, 7, 1, 3, 2, 3, 6, 6, 1, 7, 10, 0, 4, 10, 3, 5, 0, 10, 3, 10, 3, 0, 0, 1, 6, 6, 5, 9, 10, 5, 5, 9, 0, 5, 4, 1, 10, 2, 3, 1, 7, 9, 10, 10, 4, 3, 5, 9, 5, 4, 4, 8, 0, 1, 8, 1, 4, 6, 5, 6, 0, 6, 8, 6, 5, 6, 5, 7, 9, 5, 8, 8, 4, 2, 0, 0, 2, 9, 4, 9, 2, 6, 5, 2, 2, 8, 5, 4, 10, 8, 7, 7, 3, 4, 2, 0, 4, 3, 8, 6, 1, 7, 10, 10, 7, 4, 0, 6, 6, 0, 5, 6, 10, 3, 8, 3, 2, 4, 10, 4, 3, 0, 4, 10, 7, 6, 0, 4, 7, 0, 5, 2, 5, 2, 10, 9, 1, 10, 9, 6, 6, 5, 9, 10, 1, 3, 5, 2, 0, 6, 8, 5, 6, 3, 4, 8, 4, 0, 7, 0, 7, 9, 9, 1, 4, 6, 4, 5, 7, 3, 0, 4, 4, 9, 10, 5, 10, 3, 9, 6, 6, 2, 9, 4, 0, 4, 3, 3, 1, 7, 2, 1, 0, 2, 6, 7, 1, 1, 0, 3, 9, 8, 9, 4, 6, 3, 10, 7, 3, 1, 5, 2, 0, 3, 9, 5, 3, 3, 3, 1, 7, 5, 8, 10, 10, 8, 0, 2, 3, 3, 2, 9, 3, 1, 3, 9, 0, 1, 8, 2, 1, 6, 0, 6, 3, 1, 3, 1, 10, 5, 6, 0, 4, 7, 10 }, 79).PrintList();
			
			//s.MostCompetitive(new int[] { 2, 10, 6, 10, 8, 2, 7, 10, 0, 5, 1, 3, 3, 2, 8, 6, 10, 1, 2, 7, 7, 2, 8, 2, 0, 10, 5, 8, 1, 2, 4, 4, 3, 9, 6, 0, 0, 0, 10, 4, 7, 1, 2, 0, 6, 6, 0, 8, 5, 4, 4, 6, 8, 4, 10, 4, 4, 1, 5, 5, 6, 8, 3, 6, 3, 4, 6, 0, 7, 5, 5, 3, 7, 1, 4, 0, 8, 9, 4, 10, 5, 3, 3, 0, 9, 4, 10, 6, 10, 5, 5, 0, 0, 6, 1, 9, 1, 8, 10, 5, 2, 0, 9, 1, 3, 10, 5, 9, 6, 7, 6, 1, 10, 2, 3, 7, 3, 1, 4, 5, 6, 6, 5, 10, 1, 4, 6, 8, 10, 8, 3, 0, 7, 2, 10, 7, 8, 2, 1, 3, 7, 2, 4, 4, 7, 4, 7, 9, 10, 3, 7, 9, 6, 0, 9, 0, 6, 8, 0, 4, 3, 5, 5, 6, 2, 5, 4, 4, 3, 2, 8, 0, 6, 4, 9, 7, 7, 4, 10, 1, 2, 1, 10, 1, 10, 7, 10, 8, 6, 9, 1, 3, 10, 1, 6, 6, 6, 2, 6, 1, 8, 2, 1, 2, 10, 2, 5, 3, 5, 8, 6, 5, 9, 7, 10, 5, 1, 8, 0, 1, 2, 5, 8, 5, 8, 7, 2, 2, 8, 0, 4, 6, 7, 9, 3, 8, 0, 5, 6, 8, 0, 0, 10, 3, 9, 10, 10, 8, 0, 1, 3, 10, 0, 0, 7, 7, 5, 4, 2, 1, 4, 8, 4, 3, 2, 10, 0, 7, 8, 4, 3, 10, 8, 10, 2, 8, 7, 5, 10, 3, 2, 10, 5, 4, 1, 6, 2, 1, 4, 4, 7, 8, 5, 7, 10, 2, 3, 1, 7, 3, 2, 5, 5, 2, 2, 1, 10, 9, 3, 3, 4, 6, 3, 10, 6, 7, 5, 8, 0, 0, 2, 7, 6, 4, 8, 4, 0, 1, 9, 2, 6, 1, 8, 2, 7, 0, 7, 2, 7, 3, 8, 5, 2, 9, 7, 1, 3, 7, 3, 2, 8, 4, 1, 4, 3, 3, 6, 3, 8, 0, 5, 7, 8, 6, 1, 9, 7, 2, 9, 7, 4, 2, 0, 8, 4, 0, 4, 10, 9, 0, 6, 6, 9, 5, 9, 1, 2, 9, 7, 4, 5, 9, 9, 6, 4, 0, 0, 3, 5, 6, 2, 2, 8, 8, 1, 2, 10, 7, 6, 5, 8, 9, 9, 5, 0, 10, 10 }, 193).PrintList();


			//s.MostCompetitive(new int[] { 84, 10, 71, 23, 66, 61, 62, 64, 34, 41, 80, 25, 91, 43, 4, 75, 65, 13, 37, 41, 46, 90, 55, 8, 85, 61, 95, 71 }, 24).PrintList();

			s.MostCompetitive(new int[] { 2, 4, 3, 3, 5, 4, 9, 6 }, 4).PrintList();
			//s.MostCompetitive(new int[] { 11, 52, 57, 91, 47, 95, 86, 46, 87, 47, 70, 56, 54, 61, 89, 44, 3, 73, 1, 7, 87, 48, 17, 25, 49, 54, 6, 72, 97, 62, 16, 11, 47, 34, 68, 58, 14, 36, 46, 65, 2, 15 }, 18).PrintList();

				s.MostCompetitive(new int[] { 71, 18, 52, 29, 55, 73, 24, 42, 66, 8, 80, 2 }, 3).PrintList();
			s.MostCompetitive(new int[] { 3,5,2,6 }, 2).PrintList();

		}


		/// <summary>
		/// 竟然有這種做法  可以侵入式的翻新舊有的資料    從後方像是剷雪一樣  小的值從後方由下把前方大的直接鏟起來  由小的住進去
		/// 這樣子很剛好得符合了這題的各種特殊性質
		/// 說不定是先用stack寫好解答  再去湊題目的
		/// 這很像是 selection sort  小的直接移到最左    或者bubble sort  最大的鑽到最右邊
		/// 反正就是有鑽的感覺
		///
		/// 而且stack裝的是index 也是很特殊的設計
		/// 
		/// 直接用特性來match
		/// 1 小的盡量靠左     這個用由右往左比較現有的  更大則pop就能完全確保  一直左翻新
		/// 2 右方的 > k  確保pop的長度會在 k-1停止  也就是不會太短  在k很大時  恰好會保留右邊的長字串  右邊最後的結果字串會幾乎跟原本的字串的右邊相同 
		///
		/// 這樣子比下方的做法  快的地方在於不用一直計算右邊區塊的最小值
		/// 下方做法是用右邊區塊最小值  每次都計算  來判斷要不要放   n次 * n(找min)
		/// 一放就會是最準的結果
		/// 這邊stack則可以一直往左放  每次右方的值如果更小  就直接取代左邊  剛好就有右邊區塊的最小值相等效果  只要n
		/// </summary>
		public class Solution
		{
			public int[] MostCompetitive(int[] nums, int k)
			{
				Stack<int> stack = new Stack<int>();
				int[] result = new int[k];
				int p = 0;
				for (int i = 0; i < nums.Length; i++)// n
				{
					// best O 1 worst  n
					while (stack.Any() && nums[i] < nums[stack.Peek()] && nums.Length - i + stack.Count() > k)
					{
						stack.Pop();//O 1
					}
					if (stack.Count < k)
					{
						stack.Push(i);//O 1
					}
				}
				for (int i = k - 1; i >= 0; i--)
				{
					result[i] = nums[stack.Pop()];
				}
				return result;
			}
		}




		/// <summary>
		/// 73 / 85 test cases passed.
		/// test case length 41411
		///
		/// 策略   先排序 由最小的最開頭開始找  然後取到結尾  長度小於k    就換下一個
		/// 長度=K直接答案
		/// 
		/// 大於k  開始移除大的
		/// 因為前面最重要  是比前半部
		/// 所以從前面開始  第一個已經是最小  保留
		/// 第二個開始 設為j  基礎作法是  比j, j+1  移除兩者中較大的  (兩個 <> 比較 取大的移除)
		/// 但是後j+1大的  不一定直接移除  後面可能有更大的
		/// 所以是 如果 j < j+1     還要考慮 j+1  是否比 後面的都還小  是則保留 否則移除
		/// 又需要考慮後方字串的長度是否拼接後剛好等於K  不能再減  此時移除的關鍵區域則變成  前面已確定  到後面太長無法更動的部分
		/// 的中間區域  裡面要盡量保留最小的
		///
		/// 所以如果  長度   長度 9  前面已確定 3  後面還有12  那就是 4~6 是關鍵區域   因為後面6~12 假設在11有藏一個極小值 0
		/// 但是 6~11的數字都大  那那個0就沒有效果  因為在前段比較結果就出來了
		/// 所以4~6要直接決定怎麼留最小的  一樣是上面的  j+1  是否比 後面的都還小  是則保留 否則移除
		/// 每推進一個  後面的範圍就又縮小1
		/// 最差是整個4~6都移除 如果都比後面六個數字差的話  就直接拚後面的數字
		///
		/// 不過這樣到4w筆資料  就有點難確定怎麼優化  TLE
		///  
		/// </summary>
		public class Solution_V1
		{
			public int[] MostCompetitive(int[] nums, int k)
			{
				var orderNums = nums.OrderBy(n => n).ToList();//n logn
				List<int[]> ans = new List<int[]>();

				// worst n
				while (orderNums.Count > 0)
				{
					int i = 0;

					bool isNotFound = true;
					for (int j = i;j < nums.Length; j++)// n
					{
						if (nums[j] == orderNums[0])
						{
							isNotFound = false;
							i = j;
							break;
						}
					}

					if (!isNotFound)
					{

						var sub = nums.Skip(i).Take(nums.Length - i).ToList();//n
						if (sub.Count == k)
						{
							ans.Add(sub.ToArray());
						}
						else if (sub.Count > k)
						{
							for (int j = 1; j < sub.Count() - 1; j++) // n
							{
								//if(String.Join("", sub).StartsWith("0000000000000000000000"))
								//	Console.WriteLine();
								if (sub[j] <= sub[j + 1])
								{
									var minSec = sub.Skip(j + 2).Take(sub.Count - k).ToList();
									if (j < k - 1 &&
									    (sub[j + 1] > minSec.Min()))// n
									{
										sub.RemoveAt(j + 1);
										j -= 1;
									}


								}
								else if (sub[j] > sub[j + 1])
								{
									sub.RemoveAt(j);
									j -= 1;

								}

								if (sub.Count == k)
								{
									ans.Add(sub.ToArray());
									break;
								}
							}
							if (sub.Count > k)
							{
								ans.Add(sub.Take(k).ToArray());
							}
						}
						if (ans.Count > 0)
						{
							
							return ans[0];
						}
					}

					orderNums.RemoveAt(0);
				}

				return null;
			}
		}


	}
}
